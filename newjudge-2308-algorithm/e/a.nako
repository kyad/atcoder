# Union-Find
parent = []
size = []

●(Nで)UnionFind初期化とは
  -1をNだけ配列要素作成してparentに代入する。
  -1をNだけ配列要素作成してsizeに代入する。
ここまで。

●(xの)rootとは  # x: 0-indexed
  もし、parent[x]が-1ならば
    xを戻す。
  違えば
    (parent[x]のroot)を答えに代入する。
    parent[x]=答え。  # 経路圧縮。入れるとO(alpha(N))、入れないとO(log(N))
    答えを戻す。
  ここまで。
ここまで。

●(xとyが)issameとは  # x, y: 0-indexed
  rxをxのrootに定める。
  ryをyのrootに定める。
  答え = (rx == ry)。
  答えを戻す。
ここまで。

●(xとyを)uniteとは  # x, y: 0-indexed
  xのrootをrxに代入する。
  yのrootをryに代入する。
  もし、rx == ryならば、いいえを戻す。
  もし、size[rx] < size[ry]ならば、  # Union by size
    tmp = rx
    rx = ry
    ry = tmp
  ここまで。
  parent[ry] = rx
  size[rx] = size[rx] + size[ry]
  はいを戻す。
ここまで。


# 標準入力
標準入力全取得して、改行で区切り、全入力に代入する。
全入力[0]を「 」で区切り、入力行に代入する。
入力行[0]を整数変換して、Nに代入する。
入力行[1]を整数変換して、Mに代入する。

●(xとyを)エンコードとは  # x, y: 0-indexed
  [x, y]の配列最小値をxxに代入する。
  [x, y]の配列最大値をyyに代入する。
  答え = [xx, yy]
  答えを戻す。
ここまで。

NでUnionFind初期化。

M回
  全入力[1+(回数-1)]を「 」で区切り、入力行に代入する。
  入力行[0]を整数変換して、1を引いて、Uに代入する。
  入力行[1]を整数変換して、1を引いて、Vに代入する。
  UとVをunite。
ここまで。

全入力[1+M]を整数変換して、Kに代入する。
d = {}
K回
  全入力[1+M+1+(回数-1)]を「 」で区切り、入力行に代入する。
  入力行[0]を整数変換して、1を引いて、Xに代入する。
  入力行[1]を整数変換して、1を引いて、Yに代入する。
  RXをXのrootに定める。
  RYをYのrootに定める。
  RXとRYをエンコードしてキーに代入する。
  d[キー] = 1
ここまで。

全入力[1+M+1+K]を整数変換して、Qに代入する。
Q回
  全入力[1+M+1+K+1+(回数-1)]を「 」で区切り、入力行に代入する。
  入力行[0]を整数変換して、1を引いて、Pに代入する。
  入力行[1]を整数変換して、1を引いて、Qに代入する。
  RPをPのrootに定める。
  RQをQのrootに定める。
  RPとRQをエンコードしてキーに代入する。
  もし、dにキーが辞書キー存在するならば、
    「No」を表示。
  違えば、
    「Yes」を表示。
  ここまで。
ここまで。
