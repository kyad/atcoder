# Union-Find
parent = []
size = []

●(Nで)UnionFind初期化とは
  nを0からN-1まで繰り返す
    parent[n] = -1
    size[n] = 1
  ここまで。
ここまで。

●(xの)rootとは  # x: 0-indexed
  もし、parent[x]が-1ならば
    xを戻す。
  違えば
    (parent[x]のroot)を答えに代入する。
    parent[x]=答え。  # 入れるとO(alpha(N))、入れないとO(log(N))
    答えを戻す。
  ここまで。
ここまで。

●(xとyが)issameとは  # x, y: 0-indexed
  xのrootをrxに代入する。
  yのrootをryに代入する。
  答え = (rx == ry)。
  答えを戻す。
ここまで。

●(xとyを)uniteとは  # x, y: 0-indexed
  xのrootをrxに代入する。
  yのrootをryに代入する。
  もし、(rx == ry)ならば、
    いいえを戻す。
  ここまで。
  もし、size[rx] < size[ry]ならば、  # Union by size
    tmp = rx
    rx = ry
    ry = tmp
  ここまで。
  parent[ry] = rx
  size[rx] = size[rx] + size[ry]
  はいを戻す。
ここまで。


# 最大値
●(xとyの)maxとは
  もし、x<yならば
    yを戻す。
  違えば
    xを戻す。
  ここまで。
ここまで。


# 最小値
●(xとyの)minとは
  もし、x<yならば
    xを戻す。
  違えば
    yを戻す。
  ここまで。
ここまで。


# 標準入力
「/dev/stdin」を開いて、改行で区切って、全入力に代入する。
全入力[0]を「 」で区切り、入力行に代入する。
入力行[0]を整数変換して、Nに代入する。
入力行[1]を整数変換して、Mに代入する。

●(xとyを)エンコードとは  # x, y: 0-indexed
  xとyのminをxxに代入する。
  xとyのmaxをyyに代入する。
  答え = [xx, yy]
  答えを戻す。
ここまで。

NでUnionFind初期化。

M回
  全入力[1+(回数-1)]を「 」で区切り、入力行に代入する。
  入力行[0]を整数変換して、1を引いて、Uに代入する。
  入力行[1]を整数変換して、1を引いて、Vに代入する。
  UとVをunite。
ここまで。

全入力[1+M]を整数変換して、Kに代入する。
d = {}
K回
  全入力[1+M+1+(回数-1)]を「 」で区切り、入力行に代入する。
  入力行[0]を整数変換して、1を引いて、Xに代入する。
  入力行[1]を整数変換して、1を引いて、Yに代入する。
  XのrootをRXに代入する。
  YのrootをRYに代入する。
  RXとRYをエンコードしてキーに代入する。
  d[キー] = 1
ここまで。

全入力[1+M+1+K]を整数変換して、Qに代入する。
Q回
  全入力[1+M+1+K+1+(回数-1)]を「 」で区切り、入力行に代入する。
  入力行[0]を整数変換して、1を引いて、Pに代入する。
  入力行[1]を整数変換して、1を引いて、Qに代入する。
  Pのrootを、RPに代入する。
  Qのrootを、RQに代入する。
  RPとRQをエンコードしてキーに代入する。
  もし、dにキーが辞書キー存在するならば、
    「No」を表示。
  違えば、
    「Yes」を表示。
  ここまで。
ここまで。
