# ABC336 D

[1] 0-indexedで考える。
もし、iが頂点で、長さkのピラミッド数列ならば(ただし、kmax=min(i+1, N-1)としてk<=kmax)

    A[i-k+1] >= 1
    …
    A[i-2] >= k-2
    A[i-1] >= k-1
    A[i  ] >= k
    A[i+1] >= k-1
    A[i+2] >= k-2
    …
    A[i+k-1] >= 1

まとめて書くと、A[i±j] >= k-j (for j=0, 1, ..., k-1)⇔ A[i±j]+j >= k (for j=0, 1, ..., k-1)。

つまり、iを固定した時のピラミッド数列kの最大値は、jをi-kmax<j<i+kmaxで動かした時のA[i±j]+jの最小値である。

(具体例)
A[i±j]+jをBと書くことにする。サンプル1のi=2の場合

    A: 2 2 3 1 1
    B: 4 3 3 2 3

このとき、i=2に固定した時のピラミッド数列kの最大値は、min(B)=2である。


[2] iを0,...,N-1で動かしたそれぞれで、「jをi-kmax<j<i+kmaxで動かした時のA[i±j]+jの最小値」を高速に求めたい。

iを0,...,N-1で動かすと、サンプル1のBの値は以下のようになる。

    i=0の時: 2 3 5 4 5
    i=1の時: 3 2 4 3 4
    i=2の時: 4 3 3 2 3
    i=3の時: 5 4 4 1 2
    i=4の時: 6 5 5 2 1

iをi+1に動かす時、iを含めて左側は+1、iより右側は-1すればi+1の時のBを求めることができる。

    i=0の時: 2 3 5 4 5
            <-><------>
    i=1の時: 3 2 4 3 4
            <--><----->
    i=2の時: 4 3 3 2 3
            <----><--->
    i=3の時: 5 4 4 1 2
            <------><->
    i=4の時: 6 5 5 2 1

以上は遅延評価セグメント木で実装可能である。
