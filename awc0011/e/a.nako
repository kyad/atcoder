標準入力全取得して、改行で区切り、全入力に代入
全入力[0]を「 」で区切り、入力行に代入
入力行@0を整数変換して、Nに代入
入力行@1を整数変換して、Mに代入
A=[]
B=[]
iを1からNまで繰り返す
  全入力[i]を「 」で区切り、入力行に代入
  入力行@0を整数変換して、A[i]に代入
  入力行@1を整数変換して、B[i]に代入
ここまで

INF=10^12+1
dp=[]
iを0からNまで繰り返す
  dp[i]=-INFをM+1だけ配列要素作成
ここまで
dp[0][0]=0

# 最適値を計算するDP
iを1からNまで繰り返す
  jを0からMまで繰り返す
    dp[i][j]=dp[i][j]とdp[i-1][j]の最大値  # 取らない
    もし、j-A[i]>=0ならば、dp[i][j]=dp[i][j]と(dp[i-1][j-A[i]]+B[i])の最大値  # 取る
  ここまで
ここまで 
    
# 逆向きに辿る
答え="No"をNだけ配列要素作成
reach=いいえをM+1だけ配列要素作成
mx=dp[N]の配列最大値
jを0からMまで繰り返す
  もし、mx==dp[N][j]ならば、reach[j]=はい
ここまで
#iをNから1まで1ずつ減らし繰り返す
iiを1からNまで1ずつ増やし繰り返す
  i=N+1-ii
  # i-1→iの遷移で、iを使うかどうかを確認する
  next_reach=いいえをM+1だけ配列要素作成
  jを0からMまで繰り返す
    # iで取らないを選んで最適
    もし、reach[j] かつ dp[i][j]>=0 かつ dp[i-1][j]>=0 かつ dp[i][j]==dp[i-1][j] ならば、next_reach[j]=はい
    # iで取るを選んで最適
    もし、j-A[i]>=0 かつ reach[j] かつ dp[i][j]>=0 かつ dp[i-1][j-A[i]]>=0 かつ dp[i][j]==dp[i-1][j-A[i]]+B[i] ならば、
      答え[i-1]="Yes"
      next_reach[j-A[i]]=はい
    ここまで
  ここまで
  reach=next_reach
ここまで

答えを反復
  対象と言う
ここまで
